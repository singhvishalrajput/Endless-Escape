<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="./faviconn.png">

    <title>Endless Escape</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            overflow: hidden;
            background-color: #121212;
        }

        canvas {
            display: block;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #score-container {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }

        #menu-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(20, 20, 20, 0.8);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            color: white;
            pointer-events: auto;
        }

        #menu-container h1 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #00e5ff;
        }

        button {
            background-color: #00e5ff;
            color: #121212;
            border: none;
            padding: 12px 24px;
            font-size: 18px;
            cursor: pointer;
            border-radius: 30px;
            margin-top: 15px;
            transition: all 0.2s ease;
            font-weight: bold;
            pointer-events: auto;
        }

        button:hover {
            background-color: #00b8d4;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 231, 255, 0.4);
        }

        #controls-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
            text-align: center;
        }

        #game-over-screen {
            display: none;
        }

        #start-menu {
            display: none;
        }

        /* Add these styles to your existing <style> section */
.costumes-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 15px;
    margin: 20px 0;
    max-width: 500px;
    margin-left: auto;
    margin-right: auto;
}

.costume-item {
    background-color: rgba(30, 30, 30, 0.8);
    border-radius: 10px;
    padding: 15px;
    transition: all 0.2s ease;
    cursor: pointer;
    border: 2px solid transparent;
}

.costume-item:hover {
    transform: translateY(-5px);
    background-color: rgba(40, 40, 40, 0.8);
}

.costume-item.selected {
    border-color: #00e5ff;
    box-shadow: 0 0 15px rgba(0, 229, 255, 0.5);
}

.costume-preview {
    height: 70px;
    width: 70px;
    margin: 0 auto 10px;
    position: relative;
}

/* Default costume */
.default-costume::before {
    content: '';
    position: absolute;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 30px;
    height: 60px;
    background-color: #1e88e5;
    border-radius: 5px;
}

.default-costume::after {
    content: '';
    position: absolute;
    bottom: 60px;
    left: 50%;
    transform: translateX(-50%);
    width: 20px;
    height: 20px;
    background-color: #ffb74d;
    border-radius: 50%;
}

/* Ninja costume */
.ninja-costume::before {
    content: '';
    position: absolute;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 30px;
    height: 60px;
    background-color: #212121;
    border-radius: 5px;
}

.ninja-costume::after {
    content: '';
    position: absolute;
    bottom: 60px;
    left: 50%;
    transform: translateX(-50%);
    width: 20px;
    height: 20px;
    background-color: #212121;
    border-radius: 50%;
}

/* Robot costume */
.robot-costume::before {
    content: '';
    position: absolute;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 35px;
    height: 55px;
    background-color: #9e9e9e;
    border-radius: 3px;
}

.robot-costume::after {
    content: '';
    position: absolute;
    bottom: 55px;
    left: 50%;
    transform: translateX(-50%);
    width: 25px;
    height: 25px;
    background-color: #bdbdbd;
    border-radius: 5px;
}

/* Superhero costume */
.superhero-costume::before {
    content: '';
    position: absolute;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 30px;
    height: 60px;
    background-color: #f44336;
    border-radius: 5px;
}

.superhero-costume::after {
    content: '';
    position: absolute;
    bottom: 60px;
    left: 50%;
    transform: translateX(-50%);
    width: 20px;
    height: 20px;
    background-color: #ffeb3b;
    border-radius: 50%;
}

/* Athlete costume */
.athlete-costume::before {
    content: '';
    position: absolute;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 30px;
    height: 60px;
    background-color: #4caf50;
    border-radius: 5px;
}

.athlete-costume::after {
    content: '';
    position: absolute;
    bottom: 60px;
    left: 50%;
    transform: translateX(-50%);
    width: 20px;
    height: 20px;
    background-color: #ffa726;
    border-radius: 50%;
}

/* Zombie costume */
.zombie-costume::before {
    content: '';
    position: absolute;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 30px;
    height: 60px;
    background-color: #8bc34a;
    border-radius: 5px;
}

.zombie-costume::after {
    content: '';
    position: absolute;
    bottom: 60px;
    left: 50%;
    transform: translateX(-50%);
    width: 20px;
    height: 20px;
    background-color: #689f38;
    border-radius: 50%;
}

.costume-menu {
    display: block;
}

.costume-item p {
    margin-top: 10px;
    font-weight: bold;
    color: #f5f5f5;
}

#controls-hint {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    color: white;
    background-color: rgba(0, 0, 0, 0.5);
    padding: 10px 20px;
    border-radius: 10px;
    backdrop-filter: blur(5px);
    text-align: center;
    transition: opacity 0.5s ease; /* Add this for smooth fade out */
}

/* Add these styles to your existing <style> section */
    @media (max-width: 800px) {
    #score-container {
        font-size: 18px;
        top: 10px;
        left: 10px;
        padding: 8px 15px;
    }
    
    #controls-hint {
        font-size: 14px;
        padding: 8px 15px;
        width: 90%;
        max-width: 400px;
    }
    
    #menu-container {
        width: 90%;
        max-width: 350px;
        padding: 20px;
    }
    
    #menu-container h1 {
        font-size: 28px;
    }
    
    .costumes-grid {
        grid-template-columns: repeat(2, 1fr);
    }
}

#mobile-controls div {
    transition: all 0.1s ease-out;
}

/* Hide mobile controls on desktop */
@media (min-width: 801px) {
    #mobile-controls {
        display: none !important;
    }
}

    </style>
</head>
<body>
    <div id="game-container">
        <!-- Three.js will render here -->
    </div>

    <div id="ui-container">
        <div id="score-container">
            <div>SCORE: <span id="score">0</span></div>
            <div>HIGH SCORE: <span id="high-score">0</span></div>
        </div>

        <div id="controls-hint">
            Use A/D or ‚Üê/‚Üí to move left/right | W or ‚Üë to jump | S or ‚Üì to slide
        </div>

        <div id="menu-container" class="start-menu" id="start-menu">
            <h1>Endless Escape</h1>
            <p>Run through the endless city and avoid obstacles!</p>
            <button id="start-button">START GAME</button>
        </div>

        <!-- Add this to your HTML, inside the #ui-container div, before the game-over-screen div -->
        <div id="menu-container" class="costume-menu" id="costume-menu">
            <h1>SELECT YOUR RUNNER</h1>
            <div class="costumes-grid">
                <div class="costume-item selected" data-costume="default">
                    <div class="costume-preview default-costume"></div>
                    <p>Default</p>
                </div>
                <div class="costume-item" data-costume="ninja">
                    <div class="costume-preview ninja-costume"></div>
                    <p>Ninja</p>
                </div>
                <div class="costume-item" data-costume="robot">
                    <div class="costume-preview robot-costume"></div>
                    <p>Robot</p>
                </div>
                <div class="costume-item" data-costume="superhero">
                    <div class="costume-preview superhero-costume"></div>
                    <p>Superhero</p>
                </div>
                <div class="costume-item" data-costume="athlete">
                    <div class="costume-preview athlete-costume"></div>
                    <p>Athlete</p>
                </div>
                <div class="costume-item" data-costume="zombie">
                    <div class="costume-preview zombie-costume"></div>
                    <p>Zombie</p>
                </div>
            </div>
            <button id="start-with-costume-button">START GAME</button>
        </div>

        <div id="menu-container" class="game-over-screen" id="game-over-screen">
            <h1>GAME OVER</h1>
            <p>Your score: <span id="final-score">0</span></p>
            <button id="restart-button">PLAY AGAIN</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.158.0/three.module.min.js';

        // Audio elements
        let backgroundMusic, tingSFX, gameoverSFX;

        // Load audio
        function loadAudio() {
            backgroundMusic = new Audio('music.mp3');
            backgroundMusic.loop = true;
            backgroundMusic.volume = 0.01;
            backgroundMusic.preload = 'auto';
            
            tingSFX = new Audio('ting.mp3');
            tingSFX.volume = 0.6;
            tingSFX.preload = 'auto';
            
            gameoverSFX = new Audio('gameover.mp3');
            gameoverSFX.volume = 0.7;
            gameoverSFX.preload = 'auto';
            
            // Force preloading
            tingSFX.load();
            gameoverSFX.load();
        }

        // Sound functions
        function playBackgroundMusic() {
            backgroundMusic.currentTime = 0;
            backgroundMusic.play().catch(error => console.log('Audio play failed:', error));
        }

        function stopBackgroundMusic() {
            backgroundMusic.pause();
            backgroundMusic.currentTime = 0;
        }

        function playMoveSFX() {
            const tingSound = new Audio('ting.mp3');
            tingSound.volume = 0.3;
            tingSound.play().catch(error => console.log('Audio play failed:', error));
        }

        function playGameoverSFX() {
            gameoverSFX.currentTime = 0;
            gameoverSFX.play().catch(error => console.log('Audio play failed:', error));
        }
                        
        
        // Create a separate TWEEN object instead of extending THREE
        const TWEEN = {
            Tween: function(object) {
                this.object = object;
                this.valuesStart = {};
                this.valuesEnd = {};
                this.duration = 1000;
                this.easingFunction = function(k) { return k; };
                this.onCompleteCallback = null;
                
                this.to = function(properties, duration) {
                    this.valuesEnd = properties;
                    if (duration !== undefined) {
                        this.duration = duration;
                    }
                    return this;
                };
                
                this.easing = function(easing) {
                    this.easingFunction = easing;
                    return this;
                };
                
                this.onComplete = function(callback) {
                    this.onCompleteCallback = callback;
                    return this;
                };
                
                this.start = function() {
                    this.startTime = Date.now();
                    
                    for (let property in this.valuesEnd) {
                        this.valuesStart[property] = this.object[property];
                    }
                    
                    TWEEN.add(this);
                    return this;
                };
                
                this.update = function() {
                    const elapsed = Date.now() - this.startTime;
                    
                    if (elapsed >= this.duration) {
                        for (let property in this.valuesEnd) {
                            this.object[property] = this.valuesEnd[property];
                        }
                        
                        if (this.onCompleteCallback !== null) {
                            this.onCompleteCallback();
                        }
                        
                        TWEEN.remove(this);
                        return false;
                    }
                    
                    const k = this.easingFunction(elapsed / this.duration);
                    
                    for (let property in this.valuesEnd) {
                        this.object[property] = this.valuesStart[property] + (this.valuesEnd[property] - this.valuesStart[property]) * k;
                    }
                    
                    return true;
                };
                
                return this;
            },
            
            _tweens: [],
            
            add: function(tween) {
                this._tweens.push(tween);
            },
            
            remove: function(tween) {
                const i = this._tweens.indexOf(tween);
                if (i !== -1) {
                    this._tweens.splice(i, 1);
                }
            },
            
            update: function() {
        if (this._tweens.length === 0) return false;
        
        let i = 0;
        const numTweens = this._tweens.length;
        
        while (i < numTweens) {
            if (this._tweens[i].update()) {
                i++;
            } else {
                this._tweens.splice(i, 1);
                numTweens--;
            }
        }
        
        return true;
    },
            
            Easing: {
                Linear: {
                    None: function(k) { return k; }
                },
                Quadratic: {
                    In: function(k) { return k * k; },
                    Out: function(k) { return k * (2 - k); },
                    InOut: function(k) {
                        if ((k *= 2) < 1) return 0.5 * k * k;
                        return -0.5 * (--k * (k - 2) - 1);
                    }
                }
            }
        };

        // Game variables
        let scene, camera, renderer;
        let player, ground;
        let obstacles = [];
        let lanes = [4, 0, -4]; // Left, center, right
        let currentLane = 1; // Start in the center lane (index 1)
        let jumping = false;
        let sliding = false;
        let speed = 0.2;
        let speedIncrement = 0.00001;
        let score = 0;
        let highScore = localStorage.getItem('highScore') || 0;
        let gameActive = false;
        let clock = new THREE.Clock();
        
        // DOM elements
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('high-score');
        const startButton = document.getElementById('start-button');
        const startMenu = document.querySelector('.start-menu');
        const gameOverScreen = document.querySelector('.game-over-screen');
        const finalScoreElement = document.getElementById('final-score');
        const restartButton = document.getElementById('restart-button');

        // Add these variables to your game variables section
let selectedCostume = 'default';
const costumeMenu = document.querySelector('.costume-menu');
const costumeItems = document.querySelectorAll('.costume-item');
const startWithCostumeButton = document.getElementById('start-with-costume-button');

// Enable audio on mobile (needs to be triggered by user interaction)
document.addEventListener('touchstart', function() {
    // Create and play a silent sound to unlock audio
    const silentSound = new Audio();
    silentSound.play().catch(() => {});
}, { once: true });

// Update player colors based on costume
function updatePlayerAppearance() {
    // Get the player's body and head
    const body = player.children[0];
    const head = player.children[1];
    
    // Update colors based on selected costume
    switch(selectedCostume) {
        case 'default':
            body.material.color.set(0x1e88e5); // Blue
            head.material.color.set(0xffb74d); // Orange
            break;
        case 'ninja':
            body.material.color.set(0x212121); // Dark gray/black
            head.material.color.set(0x212121); // Dark gray/black
            break;
        case 'robot':
            body.material.color.set(0x9e9e9e); // Silver
            head.material.color.set(0xbdbdbd); // Light silver
            break;
        case 'superhero':
            body.material.color.set(0xf44336); // Red
            head.material.color.set(0xffeb3b); // Yellow
            break;
        case 'athlete':
            body.material.color.set(0x4caf50); // Green
            head.material.color.set(0xffa726); // Orange
            break;
        case 'zombie':
            body.material.color.set(0x8bc34a); // Light green
            head.material.color.set(0x689f38); // Dark green
            break;
    }
}

// Add event listeners for costume selection
costumeItems.forEach(item => {
    item.addEventListener('click', () => {
        // Remove selected class from all items
        costumeItems.forEach(i => i.classList.remove('selected'));
        
        // Add selected class to clicked item
        item.classList.add('selected');
        
        // Update selected costume
        selectedCostume = item.getAttribute('data-costume');
    });
});

// Modify your startButton event listener to only show the costume menu, not start the game
startButton.addEventListener('click', () => {
    startMenu.style.display = 'none';
    updatePlayerAppearance(); // Move this here
    startGame();
});

// Add event listener for start with costume button - this is where the game should actually start
startWithCostumeButton.addEventListener('click', () => {
    costumeMenu.style.display = 'none';
    startMenu.style.display = 'block';
});



        // Initialize the game
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue background
            scene.fog = new THREE.Fog(0x87CEEB, 50, 150);

            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, -10);
            camera.lookAt(0, 0, 30);

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Add this line to your init function, where you set up UI display
            costumeMenu.style.display = 'block';
            startMenu.style.display = 'none';
            gameOverScreen.style.display = 'none';

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Create ground
            createGround();

            createLaneDividers();
            
            // Create player
            createPlayer();

            // Create initial environment
            createEnvironment();

            loadAudio();

            // Update UI
            highScoreElement.textContent = highScore;

            // Fix UI display
            startMenu.style.display = 'block';
            gameOverScreen.style.display = 'none';

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', handleKeyDown);

            initMobileControls(); 

            // Add this code right after your keyboard event listener (handleKeyDown function)

// Touch control variables
let touchStartX = 0;
let touchStartY = 0;
let touchEndX = 0;
let touchEndY = 0;
let touchThreshold = 50; // Minimum swipe distance in pixels

// Add touch event listeners
function initMobileControls() {
    // Create mobile control buttons
    createMobileControlButtons();
    
    // Touch events for the entire document
    document.addEventListener('touchstart', handleTouchStart, false);
    document.addEventListener('touchmove', handleTouchMove, false);
    document.addEventListener('touchend', handleTouchEnd, false);
}

function createMobileControlButtons() {
    // Create a container for mobile controls
    const mobileControls = document.createElement('div');
    mobileControls.id = 'mobile-controls';
    mobileControls.style.position = 'absolute';
    mobileControls.style.bottom = '20px';
    mobileControls.style.left = '0';
    mobileControls.style.width = '100%';
    mobileControls.style.display = 'flex';
    mobileControls.style.justifyContent = 'space-around';
    mobileControls.style.padding = '0 10%';
    mobileControls.style.zIndex = '1000';
    mobileControls.style.pointerEvents = 'none'; // Container doesn't block other interactions
    document.getElementById('ui-container').appendChild(mobileControls);

    
    
    // Only show controls on mobile devices
    if (!isMobileDevice()) {
        mobileControls.style.display = 'none';
    }
}



function isMobileDevice() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
           (window.innerWidth <= 800);
}

function handleTouchStart(event) {
    if (!gameActive) return;
    
    touchStartX = event.touches[0].clientX;
    touchStartY = event.touches[0].clientY;
}

function handleTouchMove(event) {
    // Prevent scrolling when swiping during gameplay
    if (gameActive) {
        event.preventDefault();
    }
}

function handleTouchEnd(event) {
    if (!gameActive) return;
    
    touchEndX = event.changedTouches[0].clientX;
    touchEndY = event.changedTouches[0].clientY;
    
    // Calculate swipe direction and distance
    const deltaX = touchEndX - touchStartX;
    const deltaY = touchEndY - touchStartY;
    
    // Determine if it was a swipe or a tap
    if (Math.abs(deltaX) < 10 && Math.abs(deltaY) < 10) {
        // It was a tap, check if it was in the top half (jump) or bottom half (slide)
        const screenHeight = window.innerHeight;
        if (touchEndY < screenHeight / 2) {
            jump();
        } else {
            slide();
        }
        return;
    }
    
    // Check if horizontal or vertical swipe was stronger
    if (Math.abs(deltaX) > Math.abs(deltaY)) {
        // Horizontal swipe
        if (Math.abs(deltaX) >= touchThreshold) {
            if (deltaX > 0) {
                moveRight();
            } else {
                moveLeft();
            }
        }
    } else {
        // Vertical swipe
        if (Math.abs(deltaY) >= touchThreshold) {
            if (deltaY < 0) {
                jump();
            } else {
                slide();
            }
        }
    }
}

            startButton.addEventListener('click', startGame);
            restartButton.addEventListener('click', restartGame);

            // Start animation loop
            animate();
        }

        function createGround() {
    // Create a wider ground texture
    const groundGeometry = new THREE.PlaneGeometry(44, 1000);
    const groundMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x808080, 
        side: THREE.DoubleSide 
    });
    
    ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -1;
    ground.position.z = 450;
    ground.receiveShadow = true;
    scene.add(ground);
}

function createLaneDividers() {
  // Create painted lane dividers (dashed lines)
  for (let i = 0; i < 45; i++) {
    // Create lane divider textures (flat rectangles on the road)
    const dividerGeometry = new THREE.PlaneGeometry(0.3, 2);
    const dividerMaterial = new THREE.MeshBasicMaterial({ 
      color: 0xFFFFFF,
      side: THREE.DoubleSide
    });
    
    // Left lane divider
    const leftDivider = new THREE.Mesh(dividerGeometry, dividerMaterial);
    leftDivider.rotation.x = -Math.PI / 2;  // Flat on the road
    leftDivider.position.set(-2, -0.99, i * 10 - 10);  // Slightly above ground to prevent z-fighting
    scene.add(leftDivider);
    
    // Right lane divider
    const rightDivider = new THREE.Mesh(dividerGeometry, dividerMaterial);
    rightDivider.rotation.x = -Math.PI / 2;  // Flat on the road
    rightDivider.position.set(2, -0.99, i * 10 - 10);  // Slightly above ground to prevent z-fighting
    scene.add(rightDivider);
    
    
  }
}

function updateLaneDividers() {
  // Find all lane dividers (white plane geometries)
  scene.children.forEach(child => {
    if (child.geometry && 
        child.geometry.type === "PlaneGeometry" && 
        child.material.color.getHex() === 0xFFFFFF) {
      
      // Move divider toward player
      child.position.z -= speed;
      
      // If divider is too far behind, move it ahead
      if (child.position.z < -30) {
        child.position.z += 400;
      }
    }
  });
}

        function createPlayer() {
            // Player body
            const bodyGeometry = new THREE.BoxGeometry(1, 1.5, 1);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x1e88e5 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1;
            body.castShadow = true;

            // Player head
            const headGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffb74d });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2.25;
            head.castShadow = true;

            // Create player group
            player = new THREE.Group();
            player.add(body);
            player.add(head);
            player.position.y = -1;
            player.position.z = 0;
            player.position.x = lanes[currentLane];
            scene.add(player);
        }

        // Add this to your existing variables at the top
let buildings = [];

// Replace your createEnvironment function with this
function createEnvironment() {
    // Create initial buildings
    for (let i = 0; i < 20; i++) {
        // Left side
        let leftBuilding = createBuilding(-15, -50 + i * 40);
        buildings.push(leftBuilding);
        
        // Right side
        let rightBuilding = createBuilding(15, -30 + i * 40);
        buildings.push(rightBuilding);
    }
}

// Modify your createBuilding function to return the building
// Replace your createBuilding function with this
function createBuilding(xPos, zPos) {
    const height = 5 + Math.random() * 15;
    const width = 4 + Math.random() * 6;
    const depth = 4 + Math.random() * 6;
    
    // Main building
    const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
    const buildingMaterial = new THREE.MeshStandardMaterial({ 
        color: new THREE.Color(
            0.3 + Math.random() * 0.1,
            0.3 + Math.random() * 0.1,
            0.3 + Math.random() * 0.1
        )
    });
    
    const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
    
    // Add windows to the building
    const windowSize = 0.5;
    const windowGeometry = new THREE.BoxGeometry(windowSize, windowSize, 0.1);
    const windowMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xFFFF99, 
        emissive: 0xFFFF99,
        emissiveIntensity: 0.3
    });
    
    // Number of windows based on building size
    const windowRows = Math.floor(height / 1.5);
    const windowCols = Math.floor(width / 1.2);
    
    // Add windows to front and back
    for (let row = 0; row < windowRows; row++) {
        for (let col = 0; col < windowCols; col++) {
            // Skip some windows randomly for variety
            if (Math.random() > 0.7) continue;
            
            // Front windows
            const frontWindow = new THREE.Mesh(windowGeometry, windowMaterial);
            frontWindow.position.set(
                (col - windowCols/2 + 0.5) * 1.2,
                (row - windowRows/2 + 0.5) * 1.5,
                depth/2 + 0.05
            );
            building.add(frontWindow);
            
            // Back windows
            const backWindow = new THREE.Mesh(windowGeometry, windowMaterial);
            backWindow.position.set(
                (col - windowCols/2 + 0.5) * 1.2,
                (row - windowRows/2 + 0.5) * 1.5,
                -depth/2 - 0.05
            );
            building.add(backWindow);
        }
    }
    
    // Fix building position to be fully on either side of the track
    // Ensure buildings don't extend onto the track
    const adjustedXPos = xPos > 0 ? 
    Math.max(xPos, 12 + width/2) : 
    Math.min(xPos, -12 - width/2);
    
    building.position.set(adjustedXPos, height / 2 - 1, zPos);
    building.castShadow = true;
    building.receiveShadow = true;
    scene.add(building);
    
    return building;
}

// Add this function to update buildings
function updateBuildings() {
    for (let i = buildings.length - 1; i >= 0; i--) {
        // Move buildings toward the player
        buildings[i].position.z -= speed;
        
        // If a building is too far behind the player, recycle it
        if (buildings[i].position.z < -30) {
            // Move the building far ahead
            buildings[i].position.z += 800;
            
            // Randomize its x position slightly while keeping it on the correct side
            const side = buildings[i].position.x < 0 ? -15 : 15;
            buildings[i].position.x = side + (Math.random() * 6 - 3);
            
            // Randomize the building's appearance
            const height = 5 + Math.random() * 15;
            buildings[i].scale.y = height / 5; // Adjust height
            
            // Adjust the y position based on the new height
            buildings[i].position.y = buildings[i].scale.y * 2.5 - 1;
        }
    }
}

// Then add this line to your animate function right after updateObstacles():


function createObstacle() {
    const laneIndex = Math.floor(Math.random() * 3);
    const obstacleType = Math.random() > 0.5 ? 'car' : 'bird';
    let obstacle;

    if (obstacleType === 'car') {
        // Create a car obstacle (player needs to jump over)
        obstacle = createCar();
        obstacle.position.y = -0.5; // Slightly above ground
        obstacle.userData.type = 'car'; // Need to jump
    } else {
        // Create a bird obstacle (player needs to slide under)
        obstacle = createBird();
        obstacle.position.y = 2; // Higher up, needs to slide under
        obstacle.userData.type = 'bird'; // Need to slide
    }

    obstacle.position.x = lanes[laneIndex];
    obstacle.position.z = 100;
    scene.add(obstacle);
    obstacles.push(obstacle);
}

function createCar() {
    // Create a car group
    const car = new THREE.Group();
    
    // Car body
    const bodyGeometry = new THREE.BoxGeometry(1.8, 1, 4);
    const bodyMaterial = new THREE.MeshStandardMaterial({ 
        color: new THREE.Color(
            Math.random(),
            Math.random(),
            Math.random()
        )
    });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.castShadow = true;
    car.add(body);
    
    // Car top/cabin
    const topGeometry = new THREE.BoxGeometry(1.7, 1.5, 1.5);
    const topMaterial = new THREE.MeshStandardMaterial({ 
        color: bodyMaterial.color, 
        opacity: 0.8,
        transparent: true
    });
    const top = new THREE.Mesh(topGeometry, topMaterial);
    top.position.set(0, 0.7, 0.2);
    top.castShadow = true;
    car.add(top);
    
    // Wheels
    const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.5, 8);
    const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x111111 });
    
    // Front-left wheel
    const wheel1 = new THREE.Mesh(wheelGeometry, wheelMaterial);
    wheel1.rotation.z = Math.PI / 2;
    wheel1.position.set(-1, -0.4, -0.8);
    wheel1.castShadow = true;
    car.add(wheel1);
    
    // Front-right wheel
    const wheel2 = new THREE.Mesh(wheelGeometry, wheelMaterial);
    wheel2.rotation.z = Math.PI / 2;
    wheel2.position.set(1, -0.4, -0.8);
    wheel2.castShadow = true;
    car.add(wheel2);
    
    // Back-left wheel
    const wheel3 = new THREE.Mesh(wheelGeometry, wheelMaterial);
    wheel3.rotation.z = Math.PI / 2;
    wheel3.position.set(-1, -0.4, 0.8);
    wheel3.castShadow = true;
    car.add(wheel3);
    
    // Back-right wheel
    const wheel4 = new THREE.Mesh(wheelGeometry, wheelMaterial);
    wheel4.rotation.z = Math.PI / 2;
    wheel4.position.set(1, -0.4, 0.8);
    wheel4.castShadow = true;
    car.add(wheel4);
    
    // Headlights
    const headlightGeometry = new THREE.SphereGeometry(0.15, 8, 8);
    const headlightMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xffffcc, 
        emissive: 0xffffcc,
        emissiveIntensity: 0.5
    });
    
    // Left headlight
    const headlight1 = new THREE.Mesh(headlightGeometry, headlightMaterial);
    headlight1.position.set(-0.6, 0.1, -1.5);
    car.add(headlight1);
    
    // Right headlight
    const headlight2 = new THREE.Mesh(headlightGeometry, headlightMaterial);
    headlight2.position.set(0.6, 0.1, -1.5);
    car.add(headlight2);
    
    return car;
}

function createBird() {
    // Create a bird group
    const bird = new THREE.Group();
    
    // Bird body
    const bodyGeometry = new THREE.SphereGeometry(0.4, 8, 8);
    const bodyMaterial = new THREE.MeshStandardMaterial({ 
        color: Math.random() > 0.5 ? 0x607D8B : 0x795548 // Gray or brown birds
    });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.castShadow = true;
    bird.add(body);
    
    // Bird head
    const headGeometry = new THREE.SphereGeometry(0.25, 8, 8);
    const head = new THREE.Mesh(headGeometry, bodyMaterial);
    head.position.set(0, 0.2, 0.35);
    head.castShadow = true;
    bird.add(head);
    
    // Bird beak
    const beakGeometry = new THREE.ConeGeometry(0.1, 0.3, 8);
    const beakMaterial = new THREE.MeshStandardMaterial({ color: 0xFF9800 });
    const beak = new THREE.Mesh(beakGeometry, beakMaterial);
    beak.rotation.x = -Math.PI / 2;
    beak.position.set(0, 0.2, 0.6);
    beak.castShadow = true;
    bird.add(beak);
    
    // Bird wings
    const wingGeometry = new THREE.BoxGeometry(1.2, 0.1, 0.5);
    const wingMaterial = new THREE.MeshStandardMaterial({ color: bodyMaterial.color });
    
    // Create left wing
    const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
    leftWing.position.set(-0.7, 0.1, 0);
    leftWing.castShadow = true;
    bird.add(leftWing);
    
    // Create right wing
    const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
    rightWing.position.set(0.7, 0.1, 0);
    rightWing.castShadow = true;
    bird.add(rightWing);
    
    // Add wing flapping animation
    bird.userData.animateWings = function() {
        const time = Date.now() * 0.005;
        leftWing.rotation.z = Math.sin(time) * 0.2;
        rightWing.rotation.z = -Math.sin(time) * 0.2;
    };
    
    return bird;
}

        // Make sure your startGame function properly resets and starts the game
        function startGame() {
            gameActive = true;
            startMenu.style.display = 'none';
            costumeMenu.style.display = 'none'; // Hide costume menu too
            gameOverScreen.style.display = 'none';

            // Show controls hint initially
            document.getElementById('controls-hint').style.display = 'block';

            playBackgroundMusic();
            
            // Hide controls hint after 1 second
            setTimeout(function() {
                document.getElementById('controls-hint').style.opacity = '0';
                document.getElementById('controls-hint').style.transition = 'opacity 0.5s ease';
                
                // After fade out animation, hide completely
                setTimeout(function() {
                    document.getElementById('controls-hint').style.display = 'none';
                }, 500);
            }, 1000);

            score = 0;
            speed = 0.4;
            scoreElement.textContent = '0';
            obstacles.forEach(obstacle => scene.remove(obstacle));
            obstacles = [];
            player.position.x = lanes[1]; // Reset to center lane
            currentLane = 1;
            clock.start();
        }

        function gameOver() {
            gameActive = false;
            finalScoreElement.textContent = Math.floor(score);
            gameOverScreen.style.display = 'block';

            stopBackgroundMusic();
            playGameoverSFX();
            
            if (score > highScore) {
                highScore = Math.floor(score);
                highScoreElement.textContent = highScore;
                localStorage.setItem('highScore', highScore);
            }
        }

        function restartGame() {
            startGame();
            updatePlayerAppearance();
            playBackgroundMusic();
        }

        function handleKeyDown(event) {
    if (!gameActive) return;

    switch (event.key) {
        case 'ArrowLeft':
        case 'a':
        case 'A':
            moveLeft();
            break;
        case 'ArrowRight':
        case 'd':
        case 'D':
            moveRight();
            break;
        case 'ArrowUp':
        case 'w':
        case 'W':
        case ' ':  // Space bar
            jump();
            break;
        case 'ArrowDown':
        case 's':
        case 'S':
            slide();
            break;
    }
}

        function moveLeft() {
            if (currentLane > 0) {
                playMoveSFX();
                currentLane--;
                new TWEEN.Tween(player.position)
                    .to({ x: lanes[currentLane] }, 200)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
                    
            }
        }

        function moveRight() {
            if (currentLane < 2) {
                playMoveSFX();
                currentLane++;
                new TWEEN.Tween(player.position)
                    .to({ x: lanes[currentLane] }, 200)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
                    
            }
        }

        function jump() {
            if (!jumping) {
                
                playMoveSFX();
                jumping = true;
                
                // Store the initial position
                const startY = player.position.y;
                let t = 0;
                
                function animateJump() {
                    // Slow down the increment for a longer jump
                    t += 0.015;
                    
                    // Use a sine wave for smooth jump effect
                    // Increased height multiplier for a higher jump
                    const height = Math.sin(t * Math.PI) * 3;
                    player.position.y = startY + height;
                    
                    if (t >= 1) {
                        player.position.y = startY;
                        jumping = false;
                    } else {
                        requestAnimationFrame(animateJump);
                    }
                }
                
                animateJump();
            }
        }

        function slide() {
            if (!sliding && !jumping) {
                
                playMoveSFX();
                sliding = true;
                
                
                const slideDown = new TWEEN.Tween(player.scale)
                    .to({ y: 0.5 }, 300)
                    .easing(TWEEN.Easing.Quadratic.Out);
                    
                const slideUp = new TWEEN.Tween(player.scale)
                    .to({ y: 1 }, 300)
                    .easing(TWEEN.Easing.Quadratic.In)
                    .onComplete(function() {
                        sliding = false;
                    });
                
                slideDown.onComplete(function() {
                    setTimeout(function() {
                        slideUp.start();
                    }, 200);
                });
                
                slideDown.start();
            }
        }

        function checkCollision() {
    // Create a player bounding box for collision detection
    // We'll make it slightly smaller than the visual model for better gameplay feel
    const playerWidth = sliding ? 0.8 : 0.8;
    const playerHeight = sliding ? 1.5 : 3;
    
    const playerBounds = {
        minX: player.position.x - playerWidth/2,
        maxX: player.position.x + playerWidth/2,
        minY: player.position.y,
        maxY: player.position.y + playerHeight,
        minZ: player.position.z - 0.5,
        maxZ: player.position.z + 0.5
    };
    
    for (let i = 0; i < obstacles.length; i++) {
        const obstacle = obstacles[i];
        
        // Create an appropriate bounding box based on obstacle type
        let obstacleBounds;
        
        if (obstacle.userData.type === 'car') {
            obstacleBounds = {
                minX: obstacle.position.x - 1,
                maxX: obstacle.position.x + 1,
                minY: obstacle.position.y - 0.5,
                maxY: obstacle.position.y + 1,
                minZ: obstacle.position.z - 1.5,
                maxZ: obstacle.position.z + 1.5
            };
        } else { // bird
            obstacleBounds = {
                minX: obstacle.position.x - 1.2,
                maxX: obstacle.position.x + 1.2,
                minY: obstacle.position.y - 0.4,
                maxY: obstacle.position.y + 0.4,
                minZ: obstacle.position.z - 0.6,
                maxZ: obstacle.position.z + 0.6
            };
        }
        
        // Check for collision between player and obstacle
        if (
            playerBounds.minX < obstacleBounds.maxX &&
            playerBounds.maxX > obstacleBounds.minX &&
            playerBounds.minY < obstacleBounds.maxY &&
            playerBounds.maxY > obstacleBounds.minY &&
            playerBounds.minZ < obstacleBounds.maxZ &&
            playerBounds.maxZ > obstacleBounds.minZ
        ) {
            playGameoverSFX();
            gameOver();
            return true;
        }
    }
    
    return false;
}

        function updateObstacles() {
            // Move existing obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].position.z -= speed;
                
                // Remove obstacles that are behind the player
                if (obstacles[i].position.z < -10) {
                    scene.remove(obstacles[i]);
                    obstacles.splice(i, 1);
                }
            }
            
            // Create new obstacles periodically
            if (gameActive && obstacles.length < 5 && Math.random() < 0.02 + (speed * 0.05)) {
                createObstacle();
            }
        }

        function updatePlayer() {
            // No need for smooth movement as we're using TWEEN
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (gameActive) {
                // Update score
                score += speed;
                scoreElement.textContent = Math.floor(score);
                
                // Increase difficulty over time
                speed += speedIncrement;
                
                // Move ground to create infinite effect
                ground.position.z -= speed;
                if (ground.position.z < -50) {
                    ground.position.z = 450;
                }
                
                // Animate birds' wings
                obstacles.forEach(obstacle => {
                    if (obstacle.userData.type === 'bird' && obstacle.userData.animateWings) {
                        obstacle.userData.animateWings();
                    }
                });
                
                updateObstacles();
                updateBuildings();
                updateLaneDividers();
                checkCollision();
            }
            
            // Update TWEEN animations
            TWEEN.update();
            
            renderer.render(scene, camera);
        }

        // Initialize the game
        init();
    </script>

<a target="_blank" href="https://jam.pieter.com" style="font-family: 'system-ui', sans-serif; position: fixed; bottom: -1px; right: -1px; padding: 7px; font-size: 14px; font-weight: bold; background: #fff; color: #000; text-decoration: none; z-index: 10; border-top-left-radius: 12px; z-index: 10000; border: 1px solid #fff;">üïπÔ∏è Vibe Jam 2025</a>
</body>
</html>